#####################################
# SCRIPT DE ANALISIS DE DATOS       #
# Autor: Juan Antonio Breña Moral   #
# Email: bren@juanantonio.info      #
#####################################
# 1, Carga de Librerias             #
# 2. Carga de Datos                 #
# 3. Verificacion de datos vacios   #
# 4. Muestra de todos los graficos  #
# 5. Prediccion segun ARIMA         #
# 6. Prediccion segun Extrapolacion #
# 7. Prediccion segun Est. Robustos #
# 8. Conclusiones                   #
#####################################

# Actualmente, los metodos de prediccion se basan en:
# Metodos ARIMA 
# Extrapolacion Cuadratica
# Mediana
# Estimadores robustos: Winsorized Mean, Trimmed Mean & Huber

#
# FUNCIONES GENERICAS
#

# Funcion que carga las librerias.
CARGA_LIBRERIAS <- function(){
	cat("\nCarga de librerías\n")
	library("forecast")#Prediccion
}
  
# Funcion que genera el mensaje de cabecera.
HEADER <-function(){
	cat("\n:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::")
	cat("\n:: PREDICCION DE VENTAS  | AUTHOR: JAB | EMAIL : bren@juanantonio.info ::")
	cat("\n:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n")
}

# Funcion que permite realizar pausas, util cuando que visualizar y analizar graficos.
PAUSA <- function(MENSAJE){
	if (interactive()) {
		eval(MENSAJE)
		cat("\nPULSE INTRO PARA CONTINUAR >>")
		cat("\n")
		readline()
	}
}

#
# MENSAJES
#

MSG1 <-function(){
	cat("\n::::::::::::::::::::::::::::::::::::::::::::::")
	cat("\n:: Grafico de tendencia de datos de estudio ::")
	cat("\n::::::::::::::::::::::::::::::::::::::::::::::\n")
}

MSG2 <-function(){
	cat("\n:::::::::::::::::::::::::::::::::::::::")
	cat("\n:: Prediccion mediante mÉtodos ARIMA ::")
	cat("\n:::::::::::::::::::::::::::::::::::::::\n")
}

#
# FUNCIONES GRAFICAS
#

# Funcion que permite dividir la pantalla en tantos rectangulos como sea posible para visualizar todos los elementos de estudio.
JAB.PREDICCION.DIVISION_PANTALLA <- function(DATOS){
	N <- length(DATOS)
	if((N %% 2) == 0){
		FILA = N/2
	}else{
		FILA = (N %/% 2) +1
	}
	COLUMNA = 2
	par(mfrow = c(FILA,COLUMNA))
}

# Fucnion que permite
JAB.PREDICCION.GRAFICO_TENDENCIA <- function(DATOS){

	#JAB.PREDICCION.DIVISION_PANTALLA(DATOS)
	
	N <- length(DATOS)
	NOMBRES <- names(DATOS)
	for(i in 1:N){
		TITULO <- c(NOMBRES[i])
		plot(DATOS[[i]], type="b", xlab="Meses", ylab="Ventas" )
		title(main = TITULO)
	}
	par(las = 0)# reset to default
	par(mfrow = c(1,1))
}

#Dado un array de datos originales y un vector de datos de prediccion, se genera un grafico donde se muestra la 
JAB.PREDICCION.GRAFICO.PREDICCION <- function(DATOS,DATOS_PREDICCION,NOMBRE){

	#1. Creamos un  vector para visualizar un grafico con la tendencia tras haber predecido.
	TOTAL = length(DATOS) + length(DATOS_PREDICCION)
	ARRAY_FINAL <- c()
	ARRAY_FINAL <- DATOS
	j = 1
	for (i in (length(DATOS)+1):TOTAL){
		ARRAY_FINAL[i] <- as.numeric(DATOS_PREDICCION[[j]])
		j = j + 1
	}
	
	#2. Visualizacion de grafico
	plot(ARRAY_FINAL,type="b", xlab="Meses", ylab="Ventas")
	title(main = NOMBRE)
	EJEX <- seq(TOTAL-length(DATOS_PREDICCION),TOTAL)
	EJEY <- DATOS[[length(DATOS)]]
	j= 2
	for (i in 1:length(DATOS_PREDICCION)){
		EJEY[j] <- DATOS_PREDICCION[[i]]
		j = j+1
	}
	lines(EJEX,EJEY, type = "l", col = "red")


}

JAB.PREDICCION.GRAFICO_PREDICCIONES <- function(DATOS,PREDICCIONES){

	JAB.PREDICCION.DIVISION_PANTALLA(DATOS)
		
	NOMBRES <- names(DATOS)
	for(i in 1:length(DATOS)){
		JAB.PREDICCION.GRAFICO.PREDICCION(DATOS[[i]],PREDICCIONES[[i]],NOMBRES[i])
	}
	
	par(las = 0)# reset to default
	par(mfrow = c(1,1))
}


JAB.PREDICCION.GRAFICO_COMPARACION <- function(DATOS){
	MAX <- max(DATOS)
	MIN <- min(DATOS)
	COLORES <- rainbow(100)
	EJEY <- c(MIN,MAX)
	X <- c()
	plot(DATOS[[1]],type="b", ylim=EJEY, xlab="MESES", ylab="VENTAS")
	
	for(i in 2:length(DATOS)){
		lines(DATOS[[i]],col=COLORES[[i]], type="b")
	}
}

#
# FUNCIONES DE PREDICCION
#

JAB.PREDICCION.ARIMA <- function(DATOS,PERIODOS_PREDICCION){
	#1. Creamos la prediccion mediante el mejor modelo ARIMA.
	DATOS.TS <- ts(DATOS)
	DATOS.BEST_ARIMA <- best.arima(DATOS.TS)
	DATOS.PREDICCION <- forecast(DATOS.BEST_ARIMA,PERIODOS_PREDICCION)
	#print(DATOS.PREDICCION)

	#2. Pasamos datos de prediccion a un vector.
	DATOS_ARRAY_PREDICCION <- c()
	for (i in 1:length(DATOS.PREDICCION$mean)){
		DATOS_ARRAY_PREDICCION[i] <- as.numeric(DATOS.PREDICCION$mean[[i]])
	}

	return(DATOS_ARRAY_PREDICCION)	
}

# Algoritmo de prediccion cuadratica.
JAB.PREDICCION.INTERPOLACION_CUADRATICA <- function(DATOS,PERIODOS_PREDICCION){

	#Declaracion de variables
	N = length(DATOS)
	X = seq(0,(N-1))
	SUM_Y = sum(DATOS)
	SUM_X = sum(X)
	SUM_X2 = 0
	SUM_XY = 0
	A = 0
	B = 0

	#Calculos preliminares
	for(i in 1:N){
		SUM_X2 <- SUM_X2 + X[i]^2	
	}
	for(i in 1:N){
		SUM_XY <- SUM_XY + (X[i] * DATOS[i])
	}
	
	#Calculo de parametros de ecuacion de la recta.		
	A = ((SUM_Y*SUM_X2)-(SUM_XY*SUM_X))/((N*SUM_X2)-(SUM_X^2))
	B = ((N*SUM_XY)-(SUM_X*SUM_Y))/((N*SUM_X2)-(SUM_X^2))

	#Prediccion
	INICIO <- N + PERIODOS_PREDICCION
	FIN <- (INICIO + PERIODOS_PREDICCION)-1
	
	PREDICCION <- c()
	j = 1
	for(i in INICIO:FIN){
		PREDICCION[j] <- A+B*i
		j=j+1
	}

	#Me gustaria poder devolver una serie de objetos.
	#RESULTADOS <- list(A,B,PREDICCION)
	return(PREDICCION)
}

# Funcion que calcula predicciones mediante la mediana
JAB.PREDICCION.MEDIANA <- function(DATOS,PERIODOS_PREDICCION){
	PREDICCION <- median(DATOS)
	PREDICCIONES <- rep(PREDICCION,PERIODOS_PREDICCION)
	return(PREDICCIONES)
}

JAB.PREDICCION.MAD <- function(DATOS,PERIODOS_PREDICCION){
	PREDICCION <- mad(DATOS)
	PREDICCIONES <- rep(PREDICCION,PERIODOS_PREDICCION)
	return(PREDICCIONES)
}

JAB.PREDICCION.WINSORIZED_MEAN <- function(DATOS,PERIODOS_PREDICCION){
	PREDICCION <- win(DATOS)
	PREDICCIONES <- rep(PREDICCION,PERIODOS_PREDICCION)
	return(PREDICCIONES)
}


JAB.PREDICCION.TRIMMED_MEAN <- function(DATOS,PERIODOS_PREDICCION){
	PREDICCION <- trimse(DATOS)
	PREDICCIONES <- rep(PREDICCION,PERIODOS_PREDICCION)
	return(PREDICCIONES)
}


JAB.PREDICCION.HUBER <- function(DATOS,PERIODOS_PREDICCION){
	PREDICCION <- mest(DATOS)
	PREDICCIONES <- rep(PREDICCION,PERIODOS_PREDICCION)
	return(PREDICCIONES)
}

#
# METODOS ROBUSTOS
#

win<-function(x,tr=.2){
#
#  Compute the gamma Winsorized mean for the data in the vector x.
#
#  tr is the amount of Winsorization
#
	y<-sort(x)
	n<-length(x)
	ibot<-floor(tr*n)+1
	itop<-length(x)-ibot+1
	xbot<-y[ibot]
	xtop<-y[itop]
	y<-ifelse(y<=xbot,xbot,y)
	y<-ifelse(y>=xtop,xtop,y)
	win<-mean(y)
	win
}

trimse<-function(x,tr=.2){
#
#  Estimate the standard error of the gamma trimmed mean
#  The default amount of trimming is tr=.2.
#
	trimse<-sqrt(winvar(x,tr))/((1-2*tr)*sqrt(length(x)))
	trimse
}

winvar<-function(x,tr=.2){
#
#  Compute the gamma Winsorized variance for the data in the vector x.
#  tr is the amount of Winsorization which defaults to .2.
#
	y<-sort(x)
	n<-length(x)
	ibot<-floor(tr*n)+1
	itop<-length(x)-ibot+1
	xbot<-y[ibot]
	xtop<-y[itop]
	y<-ifelse(y<=xbot,xbot,y)
	y<-ifelse(y>=xtop,xtop,y)
	winvar<-var(y)
	winvar
}

mest<-function(x,bend=1.28){
#
#  Compute M-estimator of location using Huber's Psi.
#  The default bending constant is 1.28
#
	if(mad(x)==0)stop("MAD=0. The M-estimator cannot be computed.")
	y<-(x-median(x))/mad(x)  #mad in splus is madn in the book.
	A<-sum(hpsi(y,bend))
	B<-length(x[abs(y)<=bend])
	mest<-median(x)+mad(x)*A/B
	repeat{
	y<-(x-mest)/mad(x)
	A<-sum(hpsi(y,bend))
	B<-length(x[abs(y)<=bend])
	newmest<-mest+mad(x)*A/B
	if(abs(newmest-mest) <.0001)break
	mest<-newmest
	}
	mest
}

hpsi<-function(x,bend=1.28){
#
#   Evaluate Huber`s Psi function for each value in the vector x
#   The bending constant defaults to 1.28.
#
hpsi<-ifelse(abs(x)<=bend,x,bend*sign(x))
hpsi
}

# Funcion generica de calculo de predicciones
JAB.PREDICCION.GET_PREDICCIONES <- function(DATOS,PERIODOS_PREDICCION,TIPO_PREDICCION){
	PREDICCIONES <- data.frame()
	
	if(TIPO_PREDICCION == 1){
		cat("\nCalculando predicciones ARIMA.")
	}else if(TIPO_PREDICCION == 2){
		cat("\nCalculando predicciones mediante Interpolación Cuadrática.")
	}else if(TIPO_PREDICCION == 3){
		cat("\nCalculando predicciones mediante la Mediana.")
	}else if(TIPO_PREDICCION == 4){
		cat("\nCalculando predicciones mediante MAD.")
	}else if(TIPO_PREDICCION == 5){
		cat("\nCalculando predicciones mediante la media Winsorizada.")
	}else if(TIPO_PREDICCION == 6){
		cat("\nCalculando predicciones mediante la media Recortada.")
	}else if(TIPO_PREDICCION == 7){
		cat("\nCalculando predicciones mediante el metodo Huber.")
	}
	
	for(i in 1:length(DATOS)){

		if(TIPO_PREDICCION == 1){
			PREDICCION <- JAB.PREDICCION.ARIMA(DATOS[[i]],PERIODOS_PREDICCION)
		}else if(TIPO_PREDICCION == 2){
			PREDICCION <- JAB.PREDICCION.INTERPOLACION_CUADRATICA(DATOS[[i]],PERIODOS_PREDICCION)
		}else if(TIPO_PREDICCION == 3){
			PREDICCION <- JAB.PREDICCION.MEDIANA(DATOS[[i]],PERIODOS_PREDICCION)
		}else if(TIPO_PREDICCION == 4){
			PREDICCION <- JAB.PREDICCION.MAD(DATOS[[i]],PERIODOS_PREDICCION)
		}else if(TIPO_PREDICCION == 5){
			PREDICCION <- JAB.PREDICCION.WINSORIZED_MEAN(DATOS[[i]],PERIODOS_PREDICCION)
		}else if(TIPO_PREDICCION == 6){
			PREDICCION <- JAB.PREDICCION.TRIMMED_MEAN(DATOS[[i]],PERIODOS_PREDICCION)
		}else if(TIPO_PREDICCION == 7){
			PREDICCION <- JAB.PREDICCION.HUBER(DATOS[[i]],PERIODOS_PREDICCION)
		}
		
		if(length(PREDICCIONES) == 0){
			PREDICCIONES <- data.frame(PREDICCION)	
		}else{
			PREDICCIONES <- data.frame(PREDICCIONES,PREDICCION)
		}
	}
	cat("\nCálculo de predicciones, OK.\n")
	names(PREDICCIONES) <- names(DATOS)
	print(PREDICCIONES)
	return(PREDICCIONES)
}

#
# OTRAS FUNCIONES
#

JAB.TOOLS.MERGE <- function(VECTOR1,VECTOR2){
	TOTAL = length(VECTOR1) + length(VECTOR2)
	ARRAY_FINAL <- VECTOR1
	j = 1
	for (i in (length(VECTOR1)+1):TOTAL){
		ARRAY_FINAL[i] <- as.numeric(VECTOR2[[j]])
		j = j + 1
	}
	return(ARRAY_FINAL)
}

JAB.PREDICCION.INTEGRAR_DATOS <- function(DATOS,DATOS_PREDICCION){
	DATOS_INTEGRADOS <- c()
	
	for(i in 1:length(DATOS)){
		DATOS_INTEGRADOS <- JAB.TOOLS.MERGE(DATOS[i],DATOS_PREDICCION[i])
		print(DATOS_INTEGRADOS)	
	}
	return(DATOS_INTEGRADOS)
}


#
# PROGRAMA PRINCIPAL
#

JAB.PREDICCION.CONTROL <- function(DATOS,PERIODOS_PREDICCION,OBJETIVOS){
	HEADER()
	CARGA_LIBRERIAS()
	#VERIFICACION() #No esta implementado aun.
	#PAUSA(MSG1())
	#JAB.PREDICCION.GRAFICO_TENDENCIA(DATOS)
	
	#PAUSA(MSG2())
	#PREDICCIONES_ARIMA <- JAB.PREDICCION.GET_PREDICCIONES(DATOS,PERIODOS_PREDICCION,1)
	
	#PREDICCIONES_CUADRATICAS <- JAB.PREDICCION.GET_PREDICCIONES(DATOS,PERIODOS_PREDICCION,2)
	#JAB.PREDICCION.GRAFICO_PREDICCIONES(DATOS,PREDICCIONES_CUADRATICAS)
	
	#PREDICCIONES_MEDIANA <- JAB.PREDICCION.GET_PREDICCIONES(DATOS,PERIODOS_PREDICCION,3)
	#JAB.PREDICCION.GRAFICO_PREDICCIONES(DATOS,PREDICCIONES_MEDIANA)

	#PREDICCIONES_MAD <- JAB.PREDICCION.GET_PREDICCIONES(DATOS,PERIODOS_PREDICCION,4)
	#JAB.PREDICCION.GRAFICO_PREDICCIONES(DATOS,PREDICCIONES_MAD)

	#PREDICCIONES_WINSORIZED_MEAN <- JAB.PREDICCION.GET_PREDICCIONES(DATOS,PERIODOS_PREDICCION,5)
	#JAB.PREDICCION.GRAFICO_PREDICCIONES(DATOS,PREDICCIONES_WINSORIZED_MEAN)
	
	#PREDICCIONES_TRIMMED_MEAN <- JAB.PREDICCION.GET_PREDICCIONES(DATOS,PERIODOS_PREDICCION,6)
	#JAB.PREDICCION.GRAFICO_PREDICCIONES(DATOS,PREDICCIONES_TRIMMED_MEAN)

	PREDICCIONES_HUBER <- JAB.PREDICCION.GET_PREDICCIONES(DATOS,PERIODOS_PREDICCION,7)
	#JAB.PREDICCION.GRAFICO_PREDICCIONES(DATOS,PREDICCIONES_HUBER)
	
	#print(DATOS)
	DAT <- JAB.PREDICCION.INTEGRAR_DATOS(DATOS,PREDICCIONES_HUBER)
}

#
# CODIGOS DE EJECUCICION
#

# 1. Carga de datos de ventas.
VENTAS <- read.table("C:/Documents and Settings/JBRENA/Escritorio/VENTAS.csv",header=T,sep=";", quote="")
# 2. Preparacion de datos.
attach(VENTAS)
DELEGACIONES <- c("ESTE","CLL","SUR","NORTE","CLMS","NUCLEAR")
VENTAS_REAL <- data.frame(ESTE_R,CLL_R,SUR_R,NORTE_R,CLMS_R,NUCLEAR_R)
detach(VENTAS)
names(VENTAS_REAL) = DELEGACIONES
OBJETIVOS <- c(5500000,8500000,7800000,5709000,8000000,4800000)
names(OBJETIVOS) = DELEGACIONES

# 3. Ejecucion de sistema de gestion de ventas.
JAB.PREDICCION.CONTROL(VENTAS_REAL,3,OBJETIVOS)

VENTAS_JULIO <- c(1875000)
CLL_NEW <- JAB.TOOLS.MERGE(CLL,VENTAS_JULIO)
print(CLL_NEW)
PERIODOS_PREDICCION <- 2
PREDICCIONES_MEDIANA <- JAB.PREDICCION.MEDIANA(DATOS,PERIODOS_PREDICCION)
JAB.PREDICCION.GRAFICO.PREDICCION(DATOS,PREDICCIONES_MEDIANA)

JAB.PREDICCION.CONTROL_DE_OBJETIVOS <- function(DATOS,N_PREDICCION,OBJETIVO){
	PREDICCION <- JAB.PREDICCION.INTERPOLACION_CUADRATICA(DATOS,N_PREDICCION)
	DATOS_CONTROL <- as.numeric(c(DATOS,PREDICCION))
	SUM_DATOS <- sum(DATOS_CONTROL)
	cat("Ventas acumuladas en Ejercicio:", sum(DATOS), "\n")
	cat("Objetivo de ventas: ", OBJETIVO, "\n")
	
	if(SUM_DATOS >= OBJETIVO){
		cat("Se espera cumplir objetivos\n")
		PORCENTAJE <- ((SUM_DATOS*100)/OBJETIVO)
		cat("Porcentaje de cumplimiento: ",PORCENTAJE,"%\n")

	}else{
		cat("No se espera cumplir objetivos\n")
		PORCENTAJE <- 100 -((SUM_DATOS*100)/OBJETIVO)
		cat("Porcentaje de incumplimiento: ",PORCENTAJE,"%\n")
	}

	#par(mfrow = c(1,2))
	#plot(DATOS,type="b", xlab="Meses", ylab="Ventas" )
	#NOMBRE <- c("CLL")
	#JAB.PREDICCION.GRAFICO.PREDICCION(DATOS,PREDICCION,NOMBRE)
}

JAB.PREDICCION.CONTROL_DE_OBJETIVOS(CLL_NEW,2,8500000)


